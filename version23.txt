---------------------------------
||	version 14	       ||
---------------------------------

-> Contains thread pool to test
-> Service removed
-> Direct connection between client thread and DB in the server side

---------------------------------
||	version15	       ||
---------------------------------

-> HBase integration almost completed: Need to actually make a successful connection

---------------------------------
||	version20	       ||
--------------------------------

-> Hbase, Cassandra and MongoDB integration complete
-> Timeout removed in server and client
-> Read operations sent only to mongo
-> Benchmark only waiting for the first response to arrive
-> Implementation of operation queues for each db in client side
-> Explicit synchronization access in cassandra and hbase, due to concurrence problems on java driver. Actually in hbase read don't need to synchronized (see notes in book).
-> Synchronization accessing to the same family key and row
-> Order and Transformation phases already implemented and working properly.
-> Global client and server clock implemented. This allows us to control the message timestamps and correct evolution of a db (any updates missing? replica synchronization).
-> DB instance moved from Comm class to ServerService class.
-> Created new method with the only propose to execute any kind of operations (transformed puts/deletes or reads/scans)
-> Simplification of class HClientComm in SimpleTCPComm server side.
-> Add of some debug code to obtain the total number of operations well executed on each DB.
-> Add new callback feature in client side.
-> Add new multicast library over TCP to integrate multiple dbs.
-> Add asynchronous operations send and response waiting inside multicast library.
-> Testing different configurations of server to obtain the best performance  possible.


------------------------------------------
||		version 21		||
------------------------------------------

TODO

------------------------------------------
||		version 22		||
------------------------------------------

-> Introduction of version vector for synchronization: for now clients get their version vector from the servers and update their own. In the server side each client position (id) is update by one for each update operation. It is necessary to the server see for missing updates through the version vector sent by the client.

-> Changes in the operations API:
	Delete: We only consider valid deletes that have a collection of fields that aren't null or empty. If we allowed an empty set of fields the log would be inconsistent because it is impossible eliminate operation conflicts if we don't exactly what a particular delete operation did. (11/03/2011)

-> Changes in the cassandra's delete operation to allow elimination of single columns instead of the hole row, as it did.
-> Changes in the mongo's delete operation as in cassandra's case. As it was the operation would delete the hole row. (11/03/2011)

-> New classes created:
	MessageDispatcher: Implement the algorithms necessary to execute all operation received by a server. Where we have the chance to centralize all execution and compare different algorithms for synchronization. This allows us to make changes more easily and to stop execution in a synchronization phase in one step. (14/03/2011)

	SynchronizationManager: Manages the version vectors known by a server. Where we update client entries and verify if the server is missing client updates. (14/03/2011)

	 VersionVector(Client side and server side): Manages a single version vector. (14/03/2011)

-> We had to synchronize some methods within VersionVector (server and client side) to avoid some conflicts that may arise between gets and updates. (19/03/2011)

-> Global timer issue resolved - when a operation executes the global timer is incremented by one and set to the operation. This guarantees that every write operation executed in the DB has a different and growing timestamp associated. (21/03/11)

-> Synchronization issue resolved - Every put operation in the log has to store the values associated to the fields to be used in the synchronization process. So it was made a special class that either stores the values locally in memory or goes searching in DB when it is necessary. (21/03/11)

-> Note: When to client run simultaneously, the first one to finish shows a version vector that may miss some updates done by other clients. This is due other clients still perform operations after its death. Normal stuff. The servers have at the end all update operations counted.  


-> Introduction of a new operation type hierarchy: (14/03/2011)
	
	----------- 				|
	|Operation|				|
	-----------\				|
	     |	    \				|
	     |       \				| 	Interfaces
	     v        v				|
   ------------------  -------------------	|
   |IClientOperation|  |LoggableOperation|	|
   ------------------  -------------------	|
	|			|
	v			v
   -----------------	  -----   ------        |
   |ClientOperation|	  |Put|  |Delete|     	|
   -----------------      -----   ------	|
	  |					|	Classes
	  v					|
    ---    ------   ----   ----			|
   |Put|  |Delete| |Read| |Scan|		|
    ---    ------   ----   ----			|

---------------------------------------------------------------------------
	Log Operations

	 ---------				|
	|Operation|				|
	 ---------				|
 	     |					|	Interfaces
 	     |					|
	     v					|
	 -------------				|
	|ILogOperation|				|
	 -------------				
	     |			
	     v					|
	 ------    ---------    ----		|	  Classes
	|PutLog|  |DeleteLog|  |NoOP|		|
	 ------    ---------    ----		|



---------------------------------
||	version23	       ||
--------------------------------

-> Implementation of synchronization between server. This applied:
	- Change of log operation type hierarchy (ILogOperation extends LoggableOperation)
	- Change of PutLog and DeleteLog be run in the method orderandtransform(LoggableOperation op)
	-  Change of InternalComm class to support interpretation of internal messages (see treatInternalMessage(É)). Added new feature to allow a server to send to others its own version vector and initialize synchronization phase.
	- Implementation of sync protocol. 
	- Change of SyncManager class to implement a Thread to initiate periodically synchronization phase. (Pay attention to comments to figure out what some special code means).
	- Minor change in ServerService class to adapt execution of LogOperations. 
	- Additionally the constructor of SequencialLog class was changed to support initial size given in properties. This allows more flexibility and grow depending on expected throughput.
	- Order algorithm in StructuredLog was changed because it had an error ( while(op.compareTo(opLog) < 0){ } É )
	- Add of to new properties syncWaitingTime and serversInternalAddresses.
	- Package comm in server proxy now contains to packages external and internal. The first contains the classes that implements the channels to clients communicate with and the other implements the channels to communicate with other servers known in the system.

-> When testing sync protocol i've noticed that some operations, to sync, when applied in the log didn't respected the precedence with operations already executed. This occurred because i thought that no transformation was necessary, knowing by hand that the sync operations were already ordered and transformed in the other server. This occurs because the operations in fault are related to some client and not to family and key values, and i can't infer if there isn't some other operation in log that generates a conflict with this new one seen by the server (its like a new operation from a certain client that is outsync) . So to this matter it is necessary to order and transform this kind of operation like normal ones to guarantee consistency in log.  
	
